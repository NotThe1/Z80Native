;     File created by MakeZ80Source on Wed Apr 03 09:56:26 EDT 2019 from:
;     C:\Z80_Native\Submit.asm
;Source File name - SUBMIT.COM
;Generated by - ManualDisassembler V A.0 on Tue Apr 02 16:43:38 EDT 2019

NULL       		EQU     00H				; Null
SOH        		EQU     01H				; Start of Heading
BELL       		EQU     07H				; Bell
LF         		EQU     0AH				; Line Feed
CR         		EQU     0DH				; Carriage Return
DOLLAR     		EQU     24H				; Dollar Sign
QMARK      		EQU     3FH				; Question Mark

WBOOT			EQU		0000			; Vector to warm Boot
BDOS			EQU		0005			; Vector to OS
FCB1			EQU		05CH
FCB1TYPE		EQU		065H			; Type in fcb1
COMTAIL			EQU		080H
COMTAILCOUNT	EQU     COMTAIL
COMTAILCHARS	EQU		COMTAILCOUNT + 1

DMA				EQU		0080H			; Default DMA address
RECORDSIZE		EQU		80H				; CPM record Size

scPrintString	EQU		09H
scOpenFile		EQU		0FH
scCloseFile		EQU		10H
scDeleteFile	EQU		13H
scReadSeq		EQU		14H
scWriteSeq		EQU		15H
scMakeFile		EQU		16H

				ORG		0100H


;     <New code fragment-----from 0100 to 0102 ( 102 :  258)>
;              ORG 0100H
			JP		Start

;     <New unknown fragment-----from 0103 to 01DE ( 1DE :  478)>
;              ORG 0103H
;;               DS 0DCH
msg0:			DB		' copyright(c) 1977  digital research '
LFCR:			DB		0AH,0DH,'$'
msg1:			DB		'Error On Line $'
txtSUB:			DB		'SUB'
msg2:			DB		'No  SUB  File Present$'
msg3:			DB		'Disk Write Error$'
msg4:			DB		'Command Buffer Overflow$'
msg5:			DB		'Command Too Long$'
msg6:			DB		'Parameter Error$'
msg7:			DB		'Invalid Control Character$'
msg8:			DB		'Directory Full$'
msg9:			DB		'Cannot Close  Read/Only?$'


;              ORG 01DFH
Start:
			LD		HL,000H
			ADD		HL,SP
			LD		(CallerSP),HL		; Save callers SP
			LD		HL,TopOfStack
			LD		SP,HL				; Set our stack
			CALL	GrabComTail			; Save comtail & open SUB file
			CALL	038AH
			CALL	04FEH
			CALL	jpWBOOT
			RET

;              ORG  01F7H
printBC:
			LD		HL,msgMSB			; Set up HL to store BC
			LD		(HL),B				; Save MSB of message pointer
			DEC		HL
			LD		(HL),C       		; Save LSB of Message buffer
			LD		HL,(msgLSB)			; get what we just saved
			EX		DE,HL				; put it into DE
			LD		C,scPrintString
			CALL	jpBDOS1				; Go print it
			RET

;              ORG  0207H
openBC:
;Called with BC = FCB of file to open
			LD		HL,fcbOpenMSB		; Set up HL to store BC
			LD		(HL),B				; Save MSB of FCB
			DEC		HL
			LD		(HL),C       		; Save LSB of FCB
			LD		HL,(fcbOpenLSB)		; get what we just saved
			EX		DE,HL				; put it into DE
			LD		C,scOpenFile
			CALL	jpBDOS2				; Open the file
			LD		(osStatus),A		; Save the return status
			RET

;----------------------------------------   Close File
;              ORG  021AH
closeFile:
			LD		HL,fcbCloseMSB		; Set up HL to store BC
			LD		(HL),B				; Save MSB of fcb
			DEC		HL
			LD		(HL),C       		; Save LSB of fcb
			LD		HL,(fcbCloseLSB)	; Get what we just saved
			EX		DE,HL				; Put FCB in DE
			LD		C,scCloseFile
			CALL	jpBDOS2				; Go to BDOS to Delete
			LD		(osStatus),A		; Save the return status	
			RET
;----------------------------------------   Close File
;----------------------------------------   Delete File
;              ORG  022DH
deleteFile:
			LD		HL,fcbDelMSB		; Set up HL to store BC
			LD		(HL),B				; Save MSB of fcb
			DEC		HL
			LD		(HL),C				; Save LSB of fcb
			LD		HL,(fcbDelLSB)		; Get what we just saved
			EX		DE,HL				; Put FCB in DE
			LD		C,scDeleteFile
			CALL	jpBDOS1				; Go to BDOS to Delete
			RET
;----------------------------------------   Delete File
;              ORG  023DH
;----------------------------------------   Read Seq
readSeq:
			LD		HL,fcbReadMSB		; Set up HL to store BC
			LD		(HL),B				; Save MSB of FCB1 pointer
			DEC		HL
			LD		(HL),C       		; Save LSB of FCB1 buffer
			LD		HL,(fcbReadLSB)		; Get what we just saved
			EX		DE,HL				; Put FCB in DE
			LD		C,scReadSeq
			CALL	jpBDOS2				; Read next record
			RET
;----------------------------------------   Read Seq
;----------------------------------------   Write Seq
;              ORG  024DH
writeSeq:
; fcb is in BC
			LD		HL,fcbSubMSB		; Save the
			LD		(HL),B
			DEC		HL					; calling BC
			LD		(HL),C				;  Register value
			LD		HL,(fcbSubLSB)		; Get value into HL
			EX		DE,HL				; Move it to DE
			LD		C,scWriteSeq		; For Sys call
			CALL	jpBDOS2				; Go to BDOS
			RET
;----------------------------------------   Write Seq
;----------------------------------------   Make File
;              ORG  025DH
makeFile:
			LD		HL,fcbMakeMSB		; Save the
			LD		(HL),B
			DEC		HL					; calling BC
			LD		(HL),C				;  Register value
			LD		HL,(fcbMakeLSB)		; Get value into HL
			EX		DE,HL				; Move it to DE
			LD		C,scMakeFile		; For Sys call
			CALL	jpBDOS2				; Call BDOS
			LD		(osStatus),A		; Save the return status	
			RET
;----------------------------------------   Make File
;              ORG  0270H
;L0270:
;--------------------   Move Data    -------------------------------
MoveData:
; called with E  = Length.
;             BC = Destination
;             On Stack = Source
;
          LD  HL,movSize				; Size location Pointer
          LD  (HL),E					; Save size
          DEC  HL         				; Destination location pointer
          LD  (HL),B					; Save location MSB
          DEC  HL
          LD  (HL),C					; Save location LSB
          DEC  HL						; Source  Location Pointer
          POP  DE						; Temporary get past return address
          POP  BC						; Retrieve Source location
          LD  (HL),B					; Save location MSB
          DEC  HL
          LD  (HL),C       				; Save location LSB
          PUSH DE						; Restore return address to stack
MoveData1:
          LD   A,(movSize)				; Get the length
          DEC  A						; Adjust count
          LD  (movSize),A				; Put back
          CP  0FFH						; Did it go to Zero ?
          JP	Z,DumbRet				; Return if yes

          LD HL,(movSrc)
          PUSH HL
          LD HL,(movDest)
          POP  BC
          LD A,(BC)						; Get byte from Source
          LD  (HL),A       				; Put into Destination
          LD HL,(movSrc)
          INC  HL						; Update pointers
          LD (movSrc),HL
          LD HL,(movDest)
          INC  HL
          LD (movDest),HL
          JP  MoveData1

;L02A6:
DumbRet:
          RET
;--------------------   Move Data    -------------------------------

;     <New code fragment-----from 02A7 to 02CB ( 2CB :  715)>
;              ORG  02A7H
;L02A7:
errorExit:
; entered with BC -> String message
			LD		HL,msgMSB1			; Set up HL to store BC
			LD		(HL),B				; Save MSB of message pointer
			DEC		HL
			LD		(HL),C       		; Save LSB of Message buffer
			LD		BC,LFCR
			CALL	printBC				; Print New line
			LD		BC,msg1
			CALL	printBC				; Print Error message on line xx
			LD		BC,LineNumber
			CALL	printBC				; Print Line Number
			LD		HL,(msgLSB1)
			LD		B,H
			LD		C,L					; Get original error message
			CALL	printBC				; Print it
			LD		HL,(CallerSP)
			LD		SP,HL 				; Restore the users stack
			RET

;     <New code fragment-----from 02CC to 0308 ( 308 :  776)>
;              ORG  02CCH
;L02CC:
GrabComTail:
			LD		BC,COMTAILCHARS		; comtail$chars
			PUSH	BC
			LD		E,07FH				; comtail max size
			LD		BC,comTailTemp
			CALL	MoveData
			LD		HL,(COMTAILCOUNT)	; comtailCount
			LD		H,00H				; HL = Comtail count
			LD		BC,comTailTemp		; start of tail temp
			ADD		HL,BC				; end of tail temp
			LD		(HL),00H			; Terminate tail with 00
			LD		BC,txtSUB			; Point at String SUB (source)
			PUSH	BC					; Save for MoveData
			LD		E,03H    			; Load string size
			LD		BC,FCB1TYPE			; Point at destination
			CALL	MoveData			; Insure FCB1 is type SUB
			LD		BC,FCB1				; Point to FCB for the SUB file
			CALL	openBC				; Open the file
			LD		A,(osStatus)		; Get the return status
			CP		0FFH				; Was it successful ?
			JP		NZ,GrabComTail1		;  skip if yes
			LD		BC,msg2				; Load error message
			CALL	errorExit			; exit via error
GrabComTail1:
			LD		HL,dmaIndex			; Initialize pointer
			LD		(HL),RECORDSIZE		; Store CPM record size
			RET

;              ORG  0309H
;-----------------------   Get next char from dma read buffer
getNextChar:
; Returns with next character in Acc
			LD		A,07FH				; End of record.
			LD		HL,dmaIndex
			CP		M					; Exhausted the record
			JP		NC,getNextChar2		; Skip if not

			LD		BC,FCB1				; else read more
			CALL	readSeq				; Read the SUB file
			CP		00H					; Is this the first read ?
			JP		Z,getNextChar1			; Skip if yes
			LD		A,01AH				; else return with EOF
			RET

;L0320:
getNextChar1:
			LD		HL,dmaIndex			; initialize the dmaIndex
			LD		(HL),00H
;L0325:
getNextChar2:
			LD		A,(dmaIndex)		; Get dmaIndex value
			INC		A					; Increment it
			LD		(dmaIndex),A		; And put it back
			DEC		A					; Restore dmaIndexs original value
			LD		C,A
			LD		B,00H				; Record Index
			LD		HL,DMA				; Pointer to read buffer
			ADD		HL,BC				; Point at current byte
			
			LD		A,(HL)				; Get byte from record
			LD		(currentChar1),A	; Store it in currentChar1
			CP		CR					; Is it carriage return ?
			JP		NZ,UpCase			; Skip if not

; else adjust the line number		  
			LD		A,(LineNumber + 2)
			INC		A
			LD		(LineNumber + 2),A	; is the unit value
			LD		C,A						
			LD		A,039H
			CP		C					;  > ASCII 9 ?
			JP		NC,UpCase			;   Skip  if not
			LD		HL,LineNumber + 2
			LD		(HL),030H			; Set the unit value to ASCII 0
			DEC		HL
			LD		A,(HL)				; is the ten value
			INC		A
			LD		(HL),A
			LD		C,A
			LD		A,039H				;  > ASCII 9 ?
			CP		C
			JP		NC,UpCase			;   Skip  if not
			LD		HL,LineNumber + 1
			LD		(HL),030H			; ASCII 0
			DEC		HL					; Set the unit value to ASCII 0
			INC		M					; Set the hundreds value to ASCII 0
UpCase:
; make char upper case
			LD		A,(currentChar1)	; Get the char read
			SUB		61H					; Test against ASCII a
			CP		01AH				; is it >  ASCII a
			JP		NC,UpCase1			; Skip if not
			LD		A,(currentChar1)	; get the original char
			AND		05FH				; make it upper case
			LD		(currentChar1),A	; Put back into currentChar1
;L0374:
UpCase1:
          LD   A,(currentChar1)			; Get currentChar1
          RET
;-----------------------   Get next char from dma read buffer


; ------------------------  Write to SUB file
;              ORG  0378H
writeSUB:
;L0378:
			LD		BC,fcbSUB
			CALL	writeSeq
			CP		00H
			JP		Z,DumbRet3				; Return if no error
			LD		BC,msg3
			CALL	errorExit				; exit via error
;L0389:
DumbRet3:
          RET
; ------------------------  Write to SUB file


;     <New code fragment-----from 038A to 03E5 ( 3E5 :  997)>
;              ORG  038AH
L038A:
          LD  HL,newBuffer
          LD  (HL),00H					;#? Set to 0000 - initialize
          LD  HL,0000H
          LD (newBufferIndex),HL		;#? Set newBufferIndex to 0000
          LD  HL,passNumber
          LD  (HL),01H 					;#? Set passNumber to 01
L039A:
          LD   A,(passNumber)			; Get value #?
          RRA							; LSB Set ?
          JP	NC,DumbRet1				; RET if LSB not Set
		  
          LD  HL,commandIndex
          LD  (HL),00H					; Init commandIndex
		  
		  
L03A6:
          CALL getNextChar				; Get a char
          LD  (currentChar2),A			; Save it
          SUB  01AH						; ctrl-Z
          ADD	A,0FFH
          SBC  A,A
          PUSH AF						;#?  what ?
          LD   A,(currentChar2)			; Get back the char retrieved
          SUB  CR						; carriage return
          ADD	A,0FFH
          SBC  A,A						;#? What again
          POP  BC						; get 1st what
          LD  C,B						; both b and c are th same
          AND  C						; #?????
          RRA
          JP	NC,046BH				; Jump if 1A(EOF) or CR

          LD   A,(currentChar2)			; Get back the char retrieved
          CP  LF						; Is it a Line Feed ?
          JP	Z,0468H					;  Skip if yes
          LD   A,(currentChar2)			; Get back the char retrieved
          CP  024H						; is it $
          JP	NZ,0436H				; skip if no
; char is $
          CALL	getNextChar
          LD  (currentChar2),A
          CP  024H
          JP	NZ,03E6H
          LD HL,(currentChar2)
          LD  C,L
          CALL 04C4H
          JP  0433H

;     <New code fragment-----from 03E6 to 03FD ( 3FD : 1021)>
;              ORG  03E6H
L03E6:
          LD   A,(currentChar2)
          SUB  030H
          LD  (currentChar2),A
          LD  C,A
          LD  A,09H
          CP  C
          JP	NC,03FEH
          LD  BC,msg6
          CALL errorExit				; exit via error
          JP  0433H

;     <New code fragment-----from 03FE to 041B ( 41B : 1051)>
;              ORG  03FEH
L03FE:
          LD  HL,0E7AH
          LD  (HL),00H
          CALL 04ADH
L0406:
          LD   A,(currentChar2)
          CP  00H
          JP	Z,0422H
          LD  HL,currentChar2
          DEC  M
L0412:
          CALL 0481H
          RRA
          JP	NC,041CH
          JP  0412H

;     <New code fragment-----from 041C to 0421 ( 421 : 1057)>
;              ORG  041CH
L041C:
          CALL 04ADH
          JP  0406H

;     <New code fragment-----from 0422 to 0432 ( 432 : 1074)>
;              ORG  0422H
L0422:
          CALL 0481H
          RRA
          JP	NC,0433H
          LD HL,(0E79H)
          LD  C,L
          CALL 04C4H
          JP  0422H

;     <New code fragment-----from 0433 to 0435 ( 435 : 1077)>
;              ORG  0433H
L0433:
          JP  0468H

;     <New code fragment-----from 0436 to 0455 ( 455 : 1109)>
;              ORG  0436H
L0436:
          LD   A,(currentChar2)				; Get back the char retrieved
          CP  05EH						; Is it a Caret ^ (^s = ctrl-X)
          JP	NZ,0461H				; Skip if if caret
; here after a caret
          CALL getNextChar
          SUB  061H
          LD  (currentChar2),A
          LD  C,A
          LD  A,019H
          CP  C
          JP	NC,0456H
          LD  BC,msg7
          CALL errorExit				; exit via error
          JP  045EH

;     <New code fragment-----from 0456 to 045D ( 45D : 1117)>
;              ORG  0456H
L0456:
          LD   A,(currentChar2)
          INC  A
          LD  C,A
          CALL 04C4H

;     <New code fragment-----from 045E to 0460 ( 460 : 1120)>
;              ORG  045EH
L045E:
          JP  0468H

;     <New code fragment-----from 0461 to 0467 ( 467 : 1127)>
;              ORG  0461H
L0461:
          LD HL,(currentChar2)			; Get back the char retrieved in L
          LD  C,L						; move it to C
          CALL 04C4H

;     <New code fragment-----from 0468 to 046A ( 46A : 1130)>
;              ORG  0468H
L0468:
          JP  03A6H

;     <New code fragment-----from 046B to 047F ( 47F : 1151)>
;              ORG  046BH
L046B:
          LD   A,(currentChar2)
          SUB  0DH
          SUB  01H
          SBC  A,A
          LD  (passNumber),A
          LD HL,(commandIndex)			; Get commandIndex value
          LD  C,L
          CALL 04C4H
          JP  039AH

;     <New code fragment-----from 0480 to 0480 ( 480 : 1152)>
;              ORG  0480H
;L0480:
DumbRet1:
          RET

;     <New code fragment-----from 0481 to 04A9 ( 4A9 : 1193)>
;              ORG  0481H
L0481:
          LD HL,(0E7AH)
          LD  H,00H
          LD  BC,comTailTemp
          ADD  HL,BC
          LD  A,(HL)
          LD  (0E79H),A
          SUB  020H
          SUB  01H
          SBC  A,A
          PUSH AF
          LD   A,(0E79H)
          SUB  00H
          SUB  01H
          SBC  A,A
          POP  BC
          LD  C,B
          OR  C
          RRA
          JP	C,04AAH
          LD  HL,0E7AH
          INC  M
          LD  A,01H
          RET

;     <New code fragment-----from 04AA to 04AC ( 4AC : 1196)>
;              ORG  04AAH
L04AA:
          LD  A,00H
          RET

;     <New code fragment-----from 04AD to 04C2 ( 4C2 : 1218)>
;              ORG  04ADH
L04AD:
          LD HL,(0E7AH)
          LD  H,00H
          LD  BC,comTailTemp
          ADD  HL,BC
          LD  A,(HL)
          CP  020H
          JP	NZ,04C3H
          LD  HL,0E7AH
          INC  M
          JP  04ADH

;     <New code fragment-----from 04C3 to 04C3 ( 4C3 : 1219)>
;              ORG  04C3H
L04C3:
          RET

;     <New code fragment-----from 04C4 to 04FD ( 4FD : 1277)>
;              ORG  04C4H
L04C4:
; Called with c = value to work on
          LD  HL,currentChar3
          LD  (HL),C					; Save the value in currentChar3
          LD HL,(newBufferIndex)		; Get value from newBufferIndex
          INC  HL						; Increment it
          LD (newBufferIndex),HL		; Put it back
          LD  DE,07FFH
          CALL HLminusDE				; Did we overflow Command buffer ?
          JP	NC,04DEH				; Skip if not

          LD  BC,msg4					; Command buffer overflow
          CALL errorExit				; exit via error
L04DE:
          LD HL,(newBufferIndex)		; Get value from newBufferIndex
          LD  BC,newBuffer				; Base of newBuffer
          ADD  HL,BC
          LD   A,(currentChar3)				; Get the working value
          LD  (HL),A					; Put it in Buffer ?

          LD   A,(commandIndex)			; Get value for commandIndex
          INC  A						; Increment it
          LD  (commandIndex),A			; Put it back

          LD  C,A
          LD  A,07DH					; Max size for command
          CP  C
          JP	NC,DumbRet2				; Return if size OK
          LD  BC,msg5					; Command too long
          CALL	errorExit				; exit via error
DumbRet2:
          RET

;     <New code fragment-----from 04FE to 055E ( 55E : 1374)>
;              ORG  04FEH
L04FE:
          LD  BC,fcbSUB
          CALL deleteFile
          LD  HL,05DBH
          LD  (HL),00H
          LD  BC,fcbSUB
          CALL makeFile
          LD   A,(osStatus)
          CP  0FFH
          JP	NZ,051DH
          LD  BC,msg8
          CALL 02A7H
L051D:
          CALL 057AH
          LD  (0E7EH),A
          CP  00H
          JP	Z,0565H
          LD   A,(0E7EH)
          LD  (0080H),A					;#? COMTAILCOUNT
          LD  C,A
          LD  B,00H
          LD  HL,0081H
          ADD  HL,BC
          LD  (HL),00H
          LD HL,(0E7EH)
          LD  H,00H
          LD  BC,0082H
          ADD  HL,BC
          LD  (HL),024H
L0542:
          LD  A,00H
          LD  HL,0E7EH
          CP  M
          JP	NC,055FH
          CALL 057AH
          LD HL,(0E7EH)
          LD  H,00H
          LD  BC,0080H 					;#? COMTAILCOUNT/RECORDSIZE
          ADD  HL,BC
          LD  (HL),A
          LD  HL,0E7EH
          DEC  M
          JP  0542H

;     <New code fragment-----from 055F to 0564 ( 564 : 1380)>
;              ORG  055FH
L055F:
          CALL writeSUB				;   0378H
          JP  051DH

;     <New code fragment-----from 0565 to 0579 ( 579 : 1401)>
;              ORG  0565H
L0565:
          LD  BC,fcbSUB
          CALL closeFile
          LD   A,(osStatus)
          CP  0FFH
          JP	NZ,0579H
          LD  BC,msg9
          CALL 02A7H
L0579:
          RET

;     <New code fragment-----from 057A to 0586 ( 586 : 1414)>
;              ORG  057AH
L057A:
          LD HL,(newBufferIndex)
          DEC  HL
          LD (newBufferIndex),HL
          LD  BC,newBuffer
          ADD  HL,BC
          LD  A,(HL)
          RET

;     <New code fragment-----from 0587 to 0589 ( 589 : 1417)>
;              ORG  0587H
jpWBOOT:
          JP  WBOOT

;     <New code fragment-----from 058A to 058C ( 58C : 1420)>
;              ORG  058AH
jpBDOS1:
          JP  BDOS

;     <New code fragment-----from 058D to 058F ( 58F : 1423)>
;              ORG  058DH
jpBDOS2:
          JP  BDOS

;     <New unknown fragment-----from 0590 to 0598 ( 598 : 1432)>
;              ORG  0590H
               DS  0009H

;     <New code fragment-----from 0599 to 059F ( 59F : 1439)>
              ORG  0599H
;----------------------------HLminusDE
L0599:
HLminusDE:
          LD  A,E
          SUB  L
          LD  L,A
          LD  A,D
          SBC  A,H
          LD  H,A
          RET
;----------------------------HLminusDE


;     <New unknown fragment-----from 05A0 to 05FF ( 5FF : 1535)>
;              ORG  05A0H
;			DS		27
			ORG		05B6H
;L05B6:
LineNumber:
			DB	'001 $'

			ORG	05BBH
fcbSUB:		DB		0,'$$$    .SUB'


			ORG	05DCH
;L5DC:
msgLSB:		DS	1						; MSB of message pointer (1F7)
msgMSB:		DS	1						; LSB of message pointer

;L5DE:
osStatus:
			DS	1						; #?

			ORG	05DFH
;L5DF:
fcbOpenLSB:	DS	1						; MSB of Open pointer (207)
fcbOpenMSB:	DS	1						; LSB of Open pointer
			
;			ORG	05E1H
fcbCloseLSB:	DS	1					; LSB of fcb pointer for Close
fcbCloseMSB:	DS	1					; MSB of fcb pointer for Close

;			ORG	05E3H
fcbDelLSB:	DS	1						; LSB of fcb pointer for Delete
fcbDelMSB:	DS	1						; MSB of fcb pointer for Delete

;			ORG	05E5H
fcbReadLSB:	DS	1						; LSB of fcb pointer for Read
fcbReadMSB:	DS	1						; MSB of fcb pointer for Read

;			ORG	05E7H
fcbSubLSB:	DS	1						; LSB of fcbSUB pointer (24D)
fcbSubMSB:	DS	1						; MSB of fcbSUB pointer (24D)

;			ORG	05E9H
fcbMakeLSB:	DS	1						; LSB of fcb for Make
fcbMakeMSB:	DS	1						; MSB of fcb for Make



      			ORG		05EBH
;------- moveData Variables -------
movSrc:		DS		2					; Source pointer  for move
movDest:	DS		2					; Destination pointer for Move
movSize:	DS		1					; Size of the remaining move

;			ORG		05F0H
CallerSP:	DW	 0000

;L5F2:
msgLSB1:	DS	1						; MSB of message pointer (2A7)
msgMSB1:	DS	1						; LSB of message pointer


;L5F4:
comTailTemp:
			DS		07FH

			ORG		0674H
;L0674H:
dmaIndex:
flag1:
			DB		00H					; index into DMA record
;L0675H:
currentChar1:
			DS		1

;			ORG		0676H
L0676H:
newBuffer:
;			DS		?

			ORG		0E93H
TopOfStack:


			ORG		0E76H
L0E76H:
newBufferIndex:
			DS		2
L0E78H:
commandIndex:
			DS		1

			DS		2
L0E7BH:
currentChar3:
			DS		1
;L0E7CH:
passNumber:
			DS		1
;L0E7DH:
currentChar2:
			DS		1

EndOfCode:
